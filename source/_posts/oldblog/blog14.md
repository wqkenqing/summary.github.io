
---

title: 文本处理小结
date: 2019-07-16
tags:

---
此处简介

<!--more-->

## 文本处理小结
`此处的文本处理主要针对的是日常工作中主要遇到的一些场景小结，小结主要围绕技能展开，但不局限于某一技术点，`

### 文本处理的主要类型
1. 排序
2. 去重
3. 合并
4. 切割
4. 取集
5. 打乱排序
6. 模糊匹配
7. 替换


---

```
总得来说，目前主要的文本处理手段有linux指令、shell脚本、java脚本、mr脚本、excel、sublime等几类，下现主要也围绕这部份展开
```
### 排序
目前主要涉及到的排序手段是linux中的sort指令，所以这里对sort进行展开小结
####sort排序
sort排序主要的操作有
```sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。sort命令既可以从特定的文件，也可以从stdin中获取输入。```


#####sort 指令后面常接的Options

![3baeaf03a24f4874818f343d3893d863-image.png](//img.wqkenqing.ren/file/2017/7/3baeaf03a24f4874818f343d3893d863-image.png)




##### sort原理
sort将文件/文本的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。

排序有时往往伴随着去重，而sort则对应的有去重指令
即sort -u file:忽略相同行(这里的-u其实以对应的是unique，而unique的主要作用还是去重，所以在去重部份再展开总结)

##### sort的常用指令
(-n、-r、-k、-t)
-t:指定分隔符
-n:指定以按数字的大小的形式进行排序
-k:指定按那一列
-r:-r是以相反顺序
![5bf55dc045d846bcbe32e00202b80cbc-image.png](//img.wqkenqing.ren/file/2017/7/5bf55dc045d846bcbe32e00202b80cbc-image.png)


```careful```
-k 有一些复杂用法，即

-k选项的语法格式： FStart.CStart Modifie,FEnd.CEnd Modifier -------Start--------,-------End-------- FStart.CStart 选项 , FEnd.CEnd 选项 这个语法格式可以被其中的逗号,分为两大部分，Start部分和End部分。Start部分也由三部分组成，其中的Modifier部分就是我们之前说过的类似n和r的选项部分。我们重点说说Start部分的FStart和C.Start。C.Start也是可以省略的，省略的话就表示从本域的开头部分开始。FStart.CStart，其中FStart就是表示使用的域，而CStart则表示在FStart域中从第几个字符开始算“排序首字符”。同理，在End部分中，你可以设定FEnd.CEnd，如果你省略.CEnd，则表示结尾到“域尾”，即本域的最后一个字符。或者，如果你将CEnd设定为0(零)，也是表示结尾到“域尾”。 从公司英文名称的第二个字母开始进行排序： $ sort -t ' ' -k 1.2 facebook.txt baidu 100 5000 sohu 100 4500 google 110 5000 guge 50 3000 使用了-k 1.2，表示对第一个域的第二个字符开始到本域的最后一个字符为止的字符串进行排序。你会发现baidu因为第二个字母是a而名列榜首。sohu和 google第二个字符都是o，但sohu的h在google的o前面，所以两者分别排在第二和第三。guge只能屈居第四了。 只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序： $ sort -t ' ' -k 1.2,1.2 -nrk 3,3 facebook.txt baidu 100 5000 google 110 5000 sohu 100 4500 guge 50 3000 由于只对第二个字母进行排序，所以我们使用了-k 1.2,1.2的表示方式，表示我们“只”对第二个字母进行排序。（如果你问“我使用-k 1.2怎么不行？”，当然不行，因为你省略了End部分，这就意味着你将对从第二个字母起到本域最后一个字符为止的字符串进行排序）。对于员工工资进行排 序，我们也使用了-k 3,3，这是最准确的表述，表示我们“只”对本域进行排序，因为如果你省略了后面的3，就变成了我们“对第3个域开始到最后一个域位置的内容进行排序” 了。

---
总得来说Linux的sort排序功能就能满足绝大部份应用场景

---

### 去重

```排序完后，往往涉及到的场景更多的是去重```
相较于排序而言，日常中去重的手段会更多一些

#### 去重(linux方式)

linux中的去重指令首先是刚才在前文本提到的

sort -u:对文本进行排序，去重，并对重复的只保留一份。

而在日常中，结合去重可能会产生更多的应用场景，即取交集、并集等

大致来讲linux 主要的去重指令是uniq

##### uniq

uniq的Options主要有
![540273a5039941a39598a747888f4948-image.png](//img.wqkenqing.ren/file/2017/7/540273a5039941a39598a747888f4948-image.png)

![10bff3119aaa49de976350596f94f4bf-image.png](//img.wqkenqing.ren/file/2017/7/10bff3119aaa49de976350596f94f4bf-image.png)



uniq :默认只是将重复的保留一行

而通过uniq实现交集与并集主要通过-d与-u实现

uniq -d是只显示重复出现的行列
uniq -u是只显示不重复的列

这里要注意uniq -f -s的使用
uniq -f nubmber :即指定忽略多少栏位开如计重

uniq -s number:即指定忽略多少字任开始计重
 uniq -f -s :同时出现时则按先按栏位移，再按字符移。

通过uniq实现去重要先排序

---
针对时常出现的应用场景提供一个思路
两个文本中有重复内容，但只想去掉前一个文件与后一个文件中的重复内容，保留前一个文件中的非重复内容
可以通过

sort file1 file2 | uniq  -d >temp

sort file1 temp|uniq -u

```即思路是:先将两个文件中的重复内容找出并写入临时文件，再将前一个文件与临时文件合并，排序去重，保留只出现一次的文件内容```


---
##### 其它去重方式

要去重，通过java方式也能轻松实现
即主要利用set等的非重复内容的特性。进行实现


### 切割

即将文件进行切割，出于取样，或测试的需求考虑，可能需要从大文本中切割出一些小文件来。
对文件的切割也有很多实现方式
但从实现方式上更推荐linux指令式

#### 切割linux指令式

涉及到切割的linux指令主要有split

split命令可以将一个大文件分割成很多个小文件，有时需要将文件分割成更小的片段，比如为提高可读性，生成日志等。

![Alt text](./1493197221096.png)

具体实现都是指令式，需要注意的地方较少，不记得时则翻阅相关文档

#### 切割的其它方式

主要擅长的还有java方式

---

### 打乱排序

```
打乱排序主要用的方式有awk与excel的方式
```


#### awk方式


awk 'BEGIN{ 100000*srand();}{ printf "%s %s\n", rand(), $0}'  t |sort -k1n | awk '{gsub($1FS,""); print $0}'

#### excel方式

即通过在文本中再另加一列，生成随机数，然后对随机数列进行排序从列达到打乱的效果


---


### 模糊匹配

```文本的模糊匹配有较多应该场景,可以再多总结```

模糊匹配主要有在shell脚本中针对contains操作

和vim中的匹配操作

---